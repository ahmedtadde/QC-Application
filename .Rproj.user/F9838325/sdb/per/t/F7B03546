{
    "collab_server" : "",
    "contents" : "libraries <- function(){\n  if(!require(\"pacman\")) install.packages(\"pacman\",dependencies = T)\n  library(pacman)\n  p_load(tools)\n  p_load(bit64)\n  p_load(feather)\n  p_load(stringi)\n  p_load(stringr)\n  p_load(tidyr)\n  p_load(plyr)\n  p_load(dplyr)\n  p_load(data.table)\n  p_load(DT)\n  p_load(shiny)\n  p_load(shinythemes)\n  p_load(foreign)\n  p_load(readxl)\n  p_load(foreach)\n  p_load(snow)\n  p_load(doSNOW)\n  registerDoSNOW(makeCluster(detectCores()))\n  p_load(doParallel)\n  registerDoParallel(makeCluster(detectCores()))\n  \n}\n\n`%notin%` <-  Negate(`%in%`)\n\ntoCharacter<- function(data){\n  \n  library(stringi)\n  library(data.table)\n  \n  data <- data.table(data)\n  colNames <- names(data)\n  \n  foreach(i = 1:dim(data)[2], .packages = c(\"data.table\",\"stringi\"), .combine = cbind) %dopar%{\n    gsub(\"(^|[^0-9])0+\", \"\\\\1\", tolower(stri_trim(as.character(data[[i]]))))\n  } -> data; data <- data.table(data)\n  \n  setnames(data, names(data), colNames)\n  return(data)\n}\n\n\nReportTypeInteger <- function(x){\n  library(stringi)\n  if(!is.na(stri_split(as.character(x), fixed = \"\\\\.\")[[1]][1])){\n    return(as.integer(stri_trim(stri_split(as.character(x),fixed = \"\\\\.\")[[1]][1])))\n  }\n}\n\nReportTypeDescription <- function(x,data){\n  library(dplyr)\n  library(data.table)\n  library(stringi)\n  \n  df <- data %>% filter(data[[1]] %in% x)\n  return(stri_trim(df$Description))\n}\n\n\n\ngetDATA <- function(filename){\n  library(data.table)\n  library(readxl)\n  library(tools)\n  library(parallel)\n  \n  `%notin%` <-  Negate(`%in%`)\n  \n  if(file_ext(filename) %notin% \"xls\" | file_ext(filename) %notin% \"xlsx\"| file_ext(filename) %notin% \"xlsm\"){\n    DT <- fread(filename,\n                strip.white = T, \n                stringsAsFactors = F,\n                na.strings = c(\"\",\"NA\")\n    )\n    \n    DT <- data.table(DT[,lapply(.SD,as.character)])\n    \n    \n    return(DT)\n  }else{\n    sheets <- excel_sheets(filename)\n    foreach(i =1:length(sheets), .combine = rbind, .packages = c(\"readxl\")) %dopar%{\n      read_excel(filename, sheet = sheets[i])\n    } -> DT;\n    return(data.table(DT))\n  }\n}\n\n\ngetASCII <- function(path){\n  \n  \n  file.rename(path$datapath,paste0(path$datapath, \".xls\"))\n  table <- data.table(read_excel(paste0(path$datapath, \".xls\"), sheet = 1))\n  \n  # table <- data.table(read_excel(path, sheet = 1))\n  \n  if(all(c(\"Record Type\",\"Variable Name\",\n           \"Description\",\"Minimum value\",\n           \"Maximum value\",\"Nominal value definitions\") %in% names(table)\n  )){\n    \n    ColNames <- unique(names(table))\n    table <- data.table(data.frame(table)[,!duplicated(names(table), fromLast = T)])\n    setnames(table, names(table), ColNames)\n    \n    \n    \n    table <- table %>% select(\n      which(names(table) %in% c(\"Record Type\",\n                                \"Variable Name\",\n                                \"Description\",\n                                \"Minimum value\",\n                                \"Maximum value\",\n                                \"Nominal value definitions\"\n      )\n      )\n    )\n    \n    \n    table$`Record Type` <- unlist(parLapply(makeCluster(detectCores()), table$`Record Type`, ReportTypeInteger))\n    table <- data.table(table); setkeyv(table, \"Record Type\")\n    \n    # dt <- data.table(read_excel(path, sheet = 2))\n    dt <- data.table(read_excel(paste0(path$datapath, \".xls\"), sheet = 2))\n    setnames(dt, names(dt)[1], \"Record Type\")\n    dt <- dt %>% select(which(names(dt) %in% c(\"Record Type\",\"Description\"))) %>% filter(!is.na(Description))\n    dt$`Record Type` <- unlist(parLapply(makeCluster(detectCores()), dt$`Record Type`, ReportTypeInteger))\n    dt <- data.table(dt); setkeyv(dt, \"Record Type\")\n    \n    table$`Record Type` <- unlist(parLapply(makeCluster(detectCores()), table$`Record Type`, ReportTypeDescription, dt))\n    rm(dt)\n    return(table)\n  }else{\n    \n    return(data.table(\"STATUS\" = \"Empty\", \"MESSAGE\" = \"Selected File is NOT an ASCII Layout File\"))\n    \n  }\n}\n\n\n\ngetCUTPOINTS <- function(path){\n  library(dplyr)\n  library(data.table)\n  library(stringi)\n  library(foreach)\n  library(parallel)\n  \n  \n  table <- fread(path,strip.white = T,na.strings = c(\"\",\" \",\"NA\",0), stringsAsFactors = F)\n  if(names(table)[1] %in% \"[\") table[[1]] <- NULL\n  if(names(table)[length(names(table))] %in% \"]\") table[[length(names(table))]] <- NULL\n  \n  foreach(i =1:dim(table)[2],.combine = c)%do%{\n    if(all(table[[i]] %in% \"[\") == T) return(i)\n    if(all(table[[i]] %in% \"]\") == T) return(i)\n  } -> removeCols\n  \n  if(length(removeCols)!=0){\n    table <- data.table(select(table, -c(removeCols)))\n  }\n  \n  \n  if(dim(table)[2]==1){\n    newColNames <- stri_split(names(table),fixed = \"/\")[[1]]\n    if(length(newColNames) !=0){\n      foreach(i = 1: length(newColNames)) %do%{\n        newColNames[i] <- gsub(\"\\\\]\",\"\",newColNames[i])\n        newColNames[i] <- gsub(\"VAR\",\"\",newColNames[i])\n        newColNames[i] <- stri_trim(newColNames[i])\n      }\n    }\n    \n    newColNames <- newColNames[-c(which(newColNames %in% \"\"))]\n    \n    table <- as.data.frame(table)\n    foreach(i =1:dim(table)[1], .combine = rbind) %do%{\n      return(stri_split(table[i,],fixed = \"\\t\")[[1]])\n    } -> table; table <- data.table(table)\n    \n    foreach(i=1:dim(table)[2], .combine = c)%do%{\n      count <- which(grepl(\"\\\\]$\", table[[i]]))\n      if(length(count) == length(table[[i]])){\n        table[[i]] <- gsub(\"\\\\]\",\"\",table[[i]])\n        return(i)\n      }\n    } -> upTo\n    \n    if(length(upTo) ==1){\n      table <- data.table(select(table, c(1:upTo)))\n    }\n    \n    setnames(table, names(table), newColNames[1:upTo])\n    setnames(table, names(table)[1], \"Subject\")\n    \n    table$Subject <- gsub(\"\\\\[\",\"\",table$Subject)\n    table$Subject <- gsub(\"\\\\]\",\"\",table$Subject)\n    table$Subject <- gsub(\"\\\\(\",\"\",table$Subject)\n    table$Subject <- gsub(\"\\\\)\",\"\",table$Subject)\n    table$Subject <- stri_trim(as.character(table$Subject))\n    \n    \n  }else{\n    \n    foreach(i = 1: length(names(table))) %do%{\n      names(table)[i] <- gsub(\"\\\\]\",\"\",names(table)[i])\n      names(table)[i] <- gsub(\"\\\\[\",\"\",names(table)[i])\n      names(table)[i] <- gsub(\"/VAR\",\"\",names(table)[i], fixed = T)\n    }\n    \n    setnames(table, names(table)[1], \"Subject\")\n    table$Subject <- gsub(\"\\\\[\",\"\",table$Subject)\n    table$Subject <- gsub(\"\\\\]\",\"\",table$Subject)\n    table$Subject <- gsub(\"\\\\(\",\"\",table$Subject)\n    table$Subject <- gsub(\"\\\\)\",\"\",table$Subject)\n    table$Subject <- stri_trim(as.character(table$Subject))\n    \n  }\n  \n  table <- data.table(table); setkey(table, Subject)\n  return(table)\n}\n\n\n\n\n\n\n\n\ngetCompareFiles <- function(path){\n  \n  library('readxl')\n  \n  foreach(k = 1:length(path)) %do%{\n    if(file_ext(path[k]) %in% \"csv\"| file_ext(path[k]) %in% \"txt\"){\n      table <- fread(path[k],strip.white = T,na.strings = c(\"\",\"NA\"))\n    }else{\n      sheets <- excel_sheets(path[k])\n      foreach(i =1:length(sheets), .combine = rbind, .packages =c('readxl')) %dopar%{\n        read_excel(path[k], sheet = sheets[i])\n      } -> table; table <- data.table(table); rm(sheets)\n    }\n    \n    if(is.null(table) | !is.data.frame(table)) return(list(\"case\" = 1))\n    if(names(table)[1] %in% \"V1\") table <- data.table(table %>% select(c(2:dim(table)[2])))\n    return(list(\"data\" = table ,\"case\" = 2))\n    \n  } -> dataList ; rm(table);rm(k)\n  \n  tableList <- list()\n  foreach(k = 1:length(dataList), .combine = c) %do%{\n    if(dataList[[k]]$case == 1) return(TRUE)\n    if(dataList[[k]]$case == 2){\n      tableList[[k]] <- dataList[[k]]$data\n      return(FALSE)\n    }\n  } -> check; rm(k)\n  \n  if(all(check %in% F) %notin% T) return(list(\"data\" = NULL ,\"keyOptions\" = NULL, \"case\" = 1))\n  \n  table <- rbindlist(tableList, use.names = T) ; rm(check); rm(dataList); rm(tableList)\n  \n  possibleKeys <-  names(table)[which(grepl(\"ssid|sasid|uin|student id|studentid|myid\", names(table), ignore.case = T))]\n  return(list(\"data\" = table,\"keyOptions\" = possibleKeys, \"case\" = 2))\n}\n\n\n\n\n\nFilterBy <- function(table, columns, values){\n  \n  data <- table\n  foreach(i = 1:length(values), .combine = c, .packages= c('stringi')) %dopar%{\n    stri_split(values[i], fixed =\"::\")[[1]][1]\n  } -> filterCols \n  \n  foreach(i= 1:length(filterCols)) %do%{\n    foreach(j=1:length(values), .combine = c, .packages = c(\"stringi\",\"dplyr\")) %dopar%{\n      if(setequal(filterCols[i], stri_split(values[j], fixed =\"::\")[[1]][1])){\n        return(stri_split(values[j], fixed =\"::\")[[1]][2])\n      }\n    }-> Vals\n    \n    return(Vals)\n  }-> filterVals\n  \n  \n  foreach(i =1:length(filterCols)) %do%{\n    filterCol <- which(stri_trim(names(data)) %in% c(stri_trim(columns[as.integer(filterCols[i])])))\n    data <- data.table(data %>% filter(tolower(stri_trim(as.character(data[[filterCol]]))) %in% tolower(stri_trim(as.character(filterVals[[i]])))))\n    setkey(data, KEY)\n    \n  }\n  return(data)\n}\n\n\ncompareFiles <- function(df1,cols1,df2,cols2){\n  \n  x <- stri_trim(cols1)\n  y <- stri_trim(cols2)\n  names(df1) <- stri_trim(names(df1))\n  names(df2) <- stri_trim(names(df2))\n  \n  \n  \n  if(\"All\" %in% x){\n    x <- names(df1)[which(names(df1) != \"KEY\")]\n  }\n  \n  if(\"All\" %in% y){\n    y <- names(df2)[which(names(df2) != \"KEY\")]\n  }\n  \n  if(length(x) == length(y)){\n    \n    if(length(x) > 1){\n      foreach(i = 1:length(x), .combine = cbind) %do%{\n        data.table(select(df1, which(names(df1) %in% x[i])))\n      } -> table; table <- data.table(table)\n    }else{\n      table <- data.table(select(df1, which(names(df1) %in% x)))\n    }\n    \n    if(is.data.table(table) == T & all(dim(table) !=  0) == T){\n      dataColnames1 <- c(\"KEY\",names(table))\n      setnames(table, names(table), paste0(\"V\",1:length(x)))\n      data1 <- data.table(\"KEY\" = df1$KEY,table)\n      data1$KEY <- gsub(\"(^|[^0-9])0+\", \"\\\\1\", tolower(stri_trim(as.character(data1$KEY))))\n      setkey(data1, KEY)\n    }else{\n      return(list(\"case\"= 999))\n    }\n    \n    if(length(y) > 1){\n      foreach(i = 1:length(y), .combine = cbind) %do%{\n        data.table(select(df2, which(names(df2) %in% y[i])))\n      } -> table; table <- data.table(table)\n    }else{\n      table <- data.table(select(df2, which(names(df2) %in% y)))\n    }\n    \n    if(is.data.table(table) == T & all(dim(table) !=  0) == T){\n      dataColnames2 <- c(\"KEY\",names(table))\n      setnames(table, names(table), paste0(\"V\",1:length(y)))\n      data2 <- data.table(\"KEY\" = df2$KEY,table)\n      data2$KEY <- gsub(\"(^|[^0-9])0+\", \"\\\\1\", tolower(stri_trim(as.character(data2$KEY))))\n      setkey(data2, KEY)\n    }else{\n      return(list(\"case\"= 999))\n    }\n    \n    \n    \n    matchdataColnames <- paste0(dataColnames1,\"/==/\", dataColnames2)\n    mismatchdataColnames <- paste0(dataColnames1,\"||\", dataColnames2)\n    \n    commonKeyValues <- intersect(data1$KEY, data2$KEY)\n    \n    if(length(commonKeyValues) == 0){\n      return(list(\"case\" = 0))\n    }else{\n      \n      In1Not2  <- data.table(data1 %>% filter(KEY %in% setdiff(data1$KEY, commonKeyValues)))\n      setkey(In1Not2 ,KEY)\n      In2Not1  <- data.table(data2 %>% filter(KEY %in% setdiff(data2$KEY, commonKeyValues)))\n      setkey(In2Not1 ,KEY)\n      \n      comparisonData1 <- data.table(data1 %>% filter(KEY %in% commonKeyValues))\n      setkey(comparisonData1,KEY)\n      comparisonData2 <- data.table(data2 %>% filter(KEY %in% commonKeyValues))\n      setkey(comparisonData2,KEY)\n    }\n    \n    comparisonData1 <- toCharacter(comparisonData1); setkey(comparisonData1,KEY)\n    comparisonData2 <- toCharacter(comparisonData2); setkey(comparisonData1,KEY)\n    perfect <- data.table(intersect(comparisonData1,comparisonData2))\n    setkey(perfect, KEY)\n    rm(data1); rm(data2)\n    \n    if(setequal(dim(perfect)[1],min(dim(comparisonData1)[1], dim(comparisonData2)[1])) %in% TRUE){\n      \n      setnames(In1Not2, names(In1Not2), dataColnames1)\n      setnames(In2Not1, names(In2Not1), dataColnames2)\n      setnames(perfect, names(perfect), matchdataColnames)\n      \n      return(list(\"Match\" = perfect, \"IN-1-NOT-2\" = In1Not2 , \"IN-2-NOT-1\" = In2Not1 ,\"case\" = 1))\n    }else{\n      \n      if(dim(perfect)[1] == 0){\n        mismatch1to2 <- data.table(comparisonData1); setkey(mismatch1to2,KEY)\n      }else{\n        x <- comparisonData1$KEY[which(comparisonData1$KEY %notin% perfect$KEY)]\n        mismatch1to2 <- data.table(comparisonData1 %>% filter(KEY %in% x)); setkey(mismatch1to2,KEY)\n      }\n      rm(comparisonData1)\n      \n      \n      keys <- unique(mismatch1to2$KEY)\n      foreach(i= 1:length(keys)) %do%{\n        \n        table <- data.table(mismatch1to2 %>% filter(KEY %in% keys[i]))\n        \n        if(dim(table)[1] > 1){\n          colNames <- names(table)\n          foreach(k=1:length(colNames), .packages = 'base', .combine = cbind) %dopar%{\n            if(length(unique(table[[k]]))==1){\n              return(unique(table[[k]]))\n            }else{\n              return(paste0(unique(as.character(table[[k]])),collapse = \"_\"))\n            }\n          } -> data; data <- data.table(data); setnames(data, names(data), c(colNames))\n          \n          return(data)\n        }else{\n          return(table)\n        }\n        \n      }-> mismatch1to2\n      \n      mismatch1to2 <- rbindlist(mismatch1to2,use.names = T)\n      setkey(mismatch1to2,KEY)\n      \n      if(dim(perfect)[1] == 0){\n        mismatch2to1 <- data.table(comparisonData2); setkey(mismatch2to1,KEY)\n      }else{\n        x <- comparisonData2$KEY[which(comparisonData2$KEY %notin% perfect$KEY)]\n        mismatch2to1 <- data.table(comparisonData2 %>% filter(KEY %in% x)); setkey(mismatch2to1,KEY)\n      }\n      rm(comparisonData2)\n      \n      keys <- unique(mismatch2to1$KEY)\n      foreach(i= 1:length(keys)) %do%{\n        \n        table <- data.table(mismatch2to1 %>% filter(KEY %in% keys[i]))\n        \n        if(dim(table)[1] > 1){\n          colNames <- names(table)\n          foreach(k=1:length(colNames), .packages = 'base', .combine = cbind) %dopar%{\n            if(length(unique(table[[k]]))==1){\n              return(unique(table[[k]]))\n            }else{\n              return(paste0(unique(as.character(table[[k]]))),collapse = \"_\")\n            }\n          } -> data; data <- data.table(data); setnames(data, names(data), c(colNames))\n          \n          return(data)\n        }else{\n          return(table)\n        }\n        \n      }-> mismatch2to1\n      \n      mismatch2to1 <- rbindlist(mismatch2to1,use.names = T)\n      setkey(mismatch2to1,KEY)\n      \n      \n      \n      if(dim(mismatch2to1)[1] == dim(mismatch1to2)[1] &\n         dim(mismatch2to1)[2] == dim(mismatch1to2)[2] &\n         setequal(names(mismatch2to1), names(mismatch1to2)) %in% TRUE &\n         setequal(mismatch2to1$KEY, mismatch1to2$KEY) %in% TRUE){\n        \n        foreach(i =1:length(names(mismatch1to2)), .combine = cbind) %dopar%{\n          paste(mismatch1to2[[i]], mismatch2to1[[i]], sep = \"||\")\n        } -> difference\n        difference <- data.table(difference)\n        setnames(difference, names(difference), mismatchdataColnames)\n        setnames(In1Not2, names(In1Not2), dataColnames1)\n        setnames(In2Not1, names(In2Not1), dataColnames2)\n        setnames(perfect, names(perfect), matchdataColnames)\n        \n        return(list(\"Match\" = perfect, \"Mismatch\" = difference, \"IN-1-NOT-2\" = In1Not2,\"IN-2-NOT-1\" = In2Not1, \"case\" = 2))\n        \n      }else{\n        return(list(\"case\" = 3))\n      }\n      \n    }\n  }else{\n    return(list(\"case\" = 4))\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\nmakeMaster <- function(wd, directory, state){\n  \n  # wd = working directory\n  # directory = path to spreasheet directory\n  # state = which state\n  \n  setwd(directory)\n  selection <-  list.files(pattern = \"*.csv\") # list of all spreadsheets in directory\n  masterFiles <- which(grepl(\"master\", selection, ignore.case = T)) # find names contain word Master\n  NotMasterFiles <- which(grepl(\"^family|^label|^district|^csr\", selection, ignore.case = T))\n  if(length(NotMasterFiles) != 0){\n    masterFiles <- masterFiles[-c(NotMasterFiles)]\n  }; rm(NotMasterFiles)\n  \n  #IF there are master files\n  if(length(masterFiles) != 0){\n    selection <- selection[-c(masterFiles)] # remove master files from list\n  }; rm(masterFiles)\n  \n  #read-in data from each spreadsheet and combine results into a list object\n  DataList <- parLapply(makeCluster(detectCores()),selection,getDATA)\n  spreadsheetCount <- length(DataList)\n  \n  #extract the variables names from each data\n  colNames <- foreach(i=1:length(DataList)) %dopar%{return(names(DataList[[i]]))}\n  \n  #TWO CASES : (1) when all spreadsheets contain exactly the same variable number and names;\n  #            (2) when (1) does not apply\n  \n  \n  \n  if(setequal(Reduce(intersect, colNames), unique(unlist(colNames)))){\n    # CASE(1)\n    \n    # ROW BIND all the spreadsheets' data into one master/super data\n    DT <- rbindlist(DataList); rm(DataList); rm(selection)\n    \n    # detect all ID variables\n    ids <- names(DT)[which(grepl(\"id\", as.character(names(DT)), ignore.case = T))]\n    \n    # detect all variables related to District Identification\n    districtCols <-  names(DT)[which(grepl(\"dis|dcr\", names(DT), ignore.case = T))]\n    \n    if(length(ids) !=0 & length(districtCols) !=0){\n      \n      # detect THE District ID variable specifically ( if applicable)\n      if(length(intersect(ids, districtCols)) != 0){\n        \n        # get the district id variable and convert to INTEGER TYPE (useful for sorting master table later)\n        districtCols <- intersect(ids, districtCols)\n        foreach(k=1:length(districtCols)) %do%{\n          DT[[which(names(DT) %in% districtCols[k])]] <- as.character(DT[[which(names(DT) %in% districtCols[k])]])\n          toInteger <- as.integer(DT[[which(names(DT) %in% districtCols[k])]])\n          \n          if(all(is.na(toInteger)) %in% FALSE){\n            DT[[which(names(DT) %in% districtCols[k])]] <- toInteger\n          }\n        }\n      }\n    }\n    \n    \n    # detect all variables related to School Identification\n    schoolCols <-  names(DT)[which(grepl(\"sch|bcr\", names(DT), ignore.case = T))]\n    \n    if(length(ids) !=0 & length(schoolCols) !=0){\n      # detect THE School ID variable specifically ( if applicable)\n      if(length(intersect(ids, schoolCols)) != 0){\n        \n        # get the district id variable and convert to INTEGER TYPE (useful for sorting master table later)\n        schoolCols <- intersect(ids, schoolCols)\n        foreach(k=1:length(schoolCols)) %do%{\n          DT[[which(names(DT) %in% schoolCols[k])]] <- as.character(DT[[which(names(DT) %in% schoolCols[k])]])\n          toInteger <- as.integer(DT[[which(names(DT) %in% schoolCols[k])]])\n          \n          if(all(is.na(toInteger)) %in% FALSE){\n            DT[[which(names(DT) %in% schoolCols[k])]] <- toInteger\n          }\n        }\n      }\n    }\n    \n    \n    # detect all variables related to Grade Identification\n    gradeCols <- names(DT)[which(grepl(\"gr|sgr\", names(DT), ignore.case = T))]\n    \n    if(length(gradeCols) !=0){\n      foreach(k=1:length(gradeCols)) %do%{\n        DT[[which(names(DT) %in% gradeCols[k])]] <- as.integer(DT[[which(names(DT) %in% gradeCols[k])]])\n      }\n    }\n    \n    # subjectCols <- names(DT)[which(grepl(\"subj|test\", as.character(names(DT)), ignore.case = T))]\n    \n    if(length(districtCols) != 0 & length(schoolCols) !=0 & length(gradeCols) != 0){\n      setkeyv(DT,c(districtCols,schoolCols,gradeCols))\n    }else{\n      setkey(DT)\n    }\n    \n    rm(list = c(\"ids\",\"districtCols\",\"schoolCols\",\"gradeCols\"))\n    \n    # write.csv(DT, paste0(directory,\"/1MASTER_\",state,\".csv\"), row.names = F)\n    data.table::fwrite(DT, paste0(directory,\"/1MASTER_\",state,\".csv\"))\n    setwd(wd)\n    return(spreadsheetCount)\n  }else{   \n    \n    # CASE(2)\n    \n    # Make variables sets\n    foreach(j =1:length(colNames), .combine = c) %dopar%{\n      return(paste0(colNames[[j]], collapse = \"|\"))\n    }-> colNamesByGroup; colNamesByGroup <- unique(colNamesByGroup)\n    \n    #identify datsets related to each sets of variables \n    foreach(j =1:length(colNamesByGroup)) %do%{\n      \n      foreach(k =1:length(colNames), .combine = c, .packages = c('stringi','dplyr')) %dopar%{\n        if(setequal(colNames[[k]], stri_split(colNamesByGroup[[j]], fixed = \"|\")[[1]])) return(k)\n      }-> idx\n      \n      return(idx)\n      \n    }-> DT.byGroup\n    \n    # combine spreadsheet data based on membership to a variables set\n    foreach(j=1:length(DT.byGroup)) %do%{\n      idx <- DT.byGroup[[j]]\n      dataGroupList <- list()\n      foreach(k =1:length(idx)) %do%{\n        dataGroupList[[k]] <- DataList[[idx[k]]]\n      };rm(idx)\n      \n      return(rbindlist(dataGroupList, use.names = T))\n    }-> DT.byGroup\n    \n    \n    \n    \n    foreach(j=1:length(DT.byGroup)) %do%{\n      \n      DT <- DT.byGroup[[j]]\n      # detect all ID variables\n      ids <- names(DT)[which(grepl(\"id\", as.character(names(DT)), ignore.case = T))]\n      \n      # detect all variables related to District Identification\n      districtCols <-  names(DT)[which(grepl(\"dis|dcr\", names(DT), ignore.case = T))]\n      \n      if(length(ids) !=0 & length(districtCols) !=0){\n        \n        # detect THE District ID variable specifically ( if applicable)\n        if(length(intersect(ids, districtCols)) != 0){\n          \n          # get the district id variable and convert to INTEGER TYPE (useful for sorting master table later)\n          districtCols <- intersect(ids, districtCols)\n          foreach(k=1:length(districtCols)) %do%{\n            DT[[which(names(DT) %in% districtCols[k])]] <- as.character(DT[[which(names(DT) %in% districtCols[k])]])\n            toInteger <- as.integer(DT[[which(names(DT) %in% districtCols[k])]])\n            \n            if(all(is.na(toInteger)) %in% FALSE){\n              DT[[which(names(DT) %in% districtCols[k])]] <- toInteger\n            }\n          }\n        }\n      }\n      \n      \n      # detect all variables related to School Identification\n      schoolCols <-  names(DT)[which(grepl(\"sch|bcr\", names(DT), ignore.case = T))]\n      \n      if(length(ids) !=0 & length(schoolCols) !=0){\n        # detect THE School ID variable specifically ( if applicable)\n        if(length(intersect(ids, schoolCols)) != 0){\n          \n          # get the district id variable and convert to INTEGER TYPE (useful for sorting master table later)\n          schoolCols <- intersect(ids, schoolCols)\n          foreach(k=1:length(schoolCols)) %do%{\n            DT[[which(names(DT) %in% schoolCols[k])]] <- as.character(DT[[which(names(DT) %in% schoolCols[k])]])\n            toInteger <- as.integer(DT[[which(names(DT) %in% schoolCols[k])]])\n            \n            if(all(is.na(toInteger)) %in% FALSE){\n              DT[[which(names(DT) %in% schoolCols[k])]] <- toInteger\n            }\n          }\n        }\n      }\n      \n      \n      # detect all variables related to Grade Identification\n      gradeCols <- names(DT)[which(grepl(\"gr|sgr\", names(DT), ignore.case = T))]\n      \n      if(length(gradeCols) !=0){\n        foreach(k=1:length(gradeCols)) %do%{\n          DT[[which(names(DT) %in% gradeCols[k])]] <- as.integer(DT[[which(names(DT) %in% gradeCols[k])]])\n        }\n      }\n      \n      # subjectCols <- names(DT)[which(grepl(\"subj|test\", as.character(names(DT)), ignore.case = T))]\n      \n      if(length(districtCols) != 0 & length(schoolCols) !=0 & length(gradeCols) != 0){\n        setkeyv(DT,c(districtCols,schoolCols,gradeCols))\n      }else{\n        setkey(DT)\n      }\n      \n      rm(list = c(\"ids\",\"districtCols\",\"schoolCols\",\"gradeCols\"))\n      \n      # write.csv(DT, paste0(directory,\"/\",j,\"MASTER_\",state,\".csv\"),row.names = F)\n      \n      data.table::fwrite(DT, paste0(directory,\"/\",j,\"MASTER_\",state,\".csv\"))\n      \n    }\n    \n    setwd(wd)\n    return(spreadsheetCount)\n  }\n}",
    "created" : 1478627641223.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "628858124",
    "id" : "F7B03546",
    "lastKnownWriteTime" : 1479150666,
    "last_content_update" : 1479150666675,
    "path" : "C:/Users/temp_atadde/Desktop/MY STUFF/R Folders/QC App/functions.R",
    "project_path" : "functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}